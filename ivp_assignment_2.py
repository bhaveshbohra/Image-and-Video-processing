# -*- coding: utf-8 -*-
"""IVP_Assignment_2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1-BnwK9m5Ohom0IfZvB3po2WQ0z2kcJnV

Q1) Create two 10x10 2D arrays and perform the following operations on them using numpy:

a. Matrix multiplication
"""

import numpy as np
#retur random flaot variable
x = np.random.random((10,10)) 
#for creating 2-d arraywith ones on the diagonaland zero el
y = np.eye(10,10) 

print(x)
print(y)
print(x@y)

"""b. Inverse both matrices"""

import numpy as np
print(np.linalg.inv(y)) #compute inverse of matrix 

print(np.linalg.inv(x))
print(np.linalg.inv(x*y))

"""c. Covariance"""

import numpy as np
print(np.cov(y)) # Estimate a covaiance matrix , given data and weight
print(np.cov(x))
print(np.cov(x*y))

"""d. Compare both matrices"""

#Return Type: True, two arrays have the same elements and same shape.; otherwise False
import numpy as np
if np.array_equal(x, y): # use for compare to matrix 
    print("Equal")
else:
    print("Not Equal")

"""e. Flatten the matrices using ravel, reshape and flatten

using reshape () we can change the shape of a nmupy arrAY you need to make sure that during reshapingyou are not changing the size of the array
for example (4*3) & (6*2) it show 12 but you can not give same input same time  


using flatten you can get a 1-D array from multidimesnional array

ravel is also same as flattern in 1d array , but its return a view of the original array whenever possible
"""

# numpe.ravel function return contiguous flattened array
 # with all input array element and with tha same type
print(np.cov(y))
print(y.ravel())
print(y.reshape(1,100)) # reshaped without changing the data 

print( y.flatten()) # return copy of the array collapsed into one dimension.

# same above but matrix is x
print(np.cov(x))
print(x.ravel())
print(x.reshape(1,100))  

print( x.flatten())

"""f. Add border around the matrices

)[source]

*   numpy.pad(array, pad_width, mode='constant', **kwargs
*   array : array_like of rank N
*  pad-width Number of values padded to the edges of each axis.

â€˜constantâ€™ (default)
Pads with a constant value.
"""

array = np.pad(y, pad_width=5, mode='constant',constant_values=0)
  
print(array)

"""2.a  Convert it into grayscale image using numpy."""

import numpy as np
import matplotlib.pyplot as plt
from PIL import Image

catimg1 = Image.open('/content/cat 1.jpeg')

catarr1 = np.array(catimg1)

r,c,l = catarr1.shape

greyimg = np.zeros([r,c,3],dtype = np.uint8)

for x in range(r):
  for y in range(c):
    blue = catarr1[x,y,0]
    green = catarr1[x,y,1]
    red = catarr1[x,y,2]
    #grcl = 0.114*blue + 0.587*green + 0.299*red
    grcl = (0.333*blue + 0.333*green + 0.333*red)


    greyimg[x,y] = grcl

plt.imshow(greyimg)

"""2. b Given an image, up-sample it with a factor of 2 with the following methods: Nearest neighbor"""

import matplotlib.pyplot as plt
import numpy as np
from PIL import Image


catimg1 = Image.open("/content/cat 1.jpeg")
catarr1 = np.array(catimg1)


h,w = catarr1.shape[:2]



wNew = w * 2
hNew = h * 2


catarr2 = np.zeros([hNew, wNew, 3],dtype=np.uint8)


for i in range(hNew):
  for j in range(wNew):
    catarr2[i][j] = catarr1[(i//2)][(j//2)]


catimg2 = Image.fromarray(catarr2)
plt.imshow(catimg2)

"""Given an image, up-sample it with a factor of 2 with the following methods: Linear interpolation"""

import numpy as np
from PIL import Image
import matplotlib.pyplot as plt
 
 
 
def layerResize(catarr1) :
    height, width = catarr1.shape
 
    rNew = 2*height - 1
    cNew = 2*width - 1
    catarr2 = np.zeros((rNew, cNew))
 
    # move old points
    catarr2[::2, ::2] = catarr1[::, ::]
 
    # produce vertical values
    catarr2[1:rNew:2, 0:cNew-1:2] = (catarr2[0:rNew-1:2, 0:cNew-1:2] + catarr2[2:rNew:2, 0:cNew-1:2]) / 2
    
 
    # produce horizontal values
    catarr2[0:rNew-1:2, 1:cNew:2] = (catarr2[0:rNew-1:2, 0:cNew-1:2] + catarr2[0:rNew-1:2, 2:cNew:2]) / 2
    
 
    # produce center values
    catarr2[1:rNew:2, 1:cNew:2] = (catarr2[0:rNew-2:2, 0:cNew-2:2] +
                               catarr2[0:rNew-2:2, 2:cNew:2] +
                               catarr2[2:rNew:2, 0:cNew-2:2] +
                               catarr2[2:rNew:2, 2:cNew:2] ) / 4
 
    return catarr2
 

#main code

img1= Image.open('/content/cat 1.jpeg')

catarr1 = np.array(img1)

height, width, layers = catarr1.shape
newarr = np.zeros( [2*height - 1, 2*width - 1, layers],dtype=np.uint8 )
 
for layer in range(3) :
  newarr[:, :, layer] = layerResize(catarr1[:, :, layer])


catimg2 = Image.fromarray(newarr)  

plt.imshow(catimg2)

import numpy as np
import math
import matplotlib.pyplot as plt
from PIL import Image


def naive_image_rotate(image, degree):
    '''
    This function rotates the image around its center by amount of degrees
    provided. The size of the rotated image is same as that of original image.
    '''
    # First we will convert the degrees into radians
    rads = math.radians(degree)

    # We consider the rotated image to be of the same size as the original

    r,c,l = image.shape

    rot_img = np.zeros([r,c,3],dtype = np.uint8)
    

    # Finding the center point of rotated (or original) image.
    height = rot_img.shape[0]
    width  = rot_img.shape[1]

    midx,midy = (width//2, height//2)

    for i in range(height):
        for j in range(width):
            x= (i-midx)*math.cos(rads)+(j-midy)*math.sin(rads)
            y= -(i-midx)*math.sin(rads)+(j-midy)*math.cos(rads)

            x=round(x)+midx 
            y=round(y)+midy 

            if (x>=0 and y>=0 and x<image.shape[0] and  y<image.shape[1]):
                rot_img[i,j,:] = image[x,y,:]

    return rot_img 



image1 = Image.open("cat1.jpg")
image = np.array(image1)


angle = int(input("Enter The Angle to rotate an image: "))
rotated_image = naive_image_rotate(image,angle)
plt.imshow(image)

plt.imshow(rotated_image)

plt.hist(catarr1.ravel(), bins=256, range=(0.0, 1.0), fc='k', ec='k')

