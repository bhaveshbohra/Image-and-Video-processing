# -*- coding: utf-8 -*-
"""IVP Assignment1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1-A-8NPD6GmOOl7flJhPe9OGcq6bqzpKV

01 Create an 8x8 matrix and fill it with a checkerboard pattern. Display the result as shown below:
"""

import numpy as np
import matplotlib.pyplot as plt
white = np.zeros((100,100), dtype = np.uint8)
black = np.ones((10,10), dtype = np.uint8)
white[0:10, 0:10] = black
white[10:20, 10:20] = black
square = white[0:20, 0:20]
chess = np.tile(square, (4,4))
plt.imshow(chess, cmap='gray')

"""02  Given two images, compare them by their spatial resolution (use dpi) stating which image is better.

> Indented block


"""

#Comparision of two immages (dpi)
from PIL import Image
im1 = Image.open("/content/cat 1.jpeg")
im2 = Image.open("/content/cat 2.jpeg")
a= im1.info['dpi']
b= im2.info['dpi']
if(a>b):
  print('Cat1 is better image')
else:
  print('Cat2 is better image')
print(a,b)

from google.colab import drive
drive.mount('/content/drive')

"""### Q3) Given an image, up-sample it with a factor of 2 with the following two methods:
a) Nearest neighbor

b) Linear interpolation 
"""

# using matplotlib and numpy
import matplotlib.image as img
import numpy as npy
# provide the location of image for reading
m = img.imread("taj.png");
# determining the length of original image
w, h = m.shape[:2];
# xNew and yNew are new width and
# height of image required
xNew = int(w * 2);
yNew = int(h * 2);
# calculating the scaling factor
# work for more than 2 pixel
xScale = xNew/(w-1);
yScale = yNew/(h-1);
# using numpy taking a matrix of xNew
# width and yNew height with
# 4 attribute [alpha, B, G, B] values
newImage = npy.zeros([xNew, yNew, 4]);
for i in range(xNew-1):
for j in range(yNew-1):
newImage[i + 1, j + 1]= m[1 + int(i / xScale),
1 + int(j / yScale)]
# Save the image after scaling
img.imsave('scaled1.png', newImage);