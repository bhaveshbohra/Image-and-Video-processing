# -*- coding: utf-8 -*-
"""Ivp_Assignment_3. ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1CnZUEb5oh0v_ahemhcFaXhOa5Q5NwboN

1 log transformation
"""

import cv2
import numpy as np
import matplotlib.pyplot as plt
   
# Read an image
image = cv2.imread('/content/fourier.png')

# Apply log transformation method
c = 255 / np.log(1 + np.max(image))

log_image = c * (np.log(image + 1))
   
# Specify the data type so that
# float value will be converted to int
log_image = np.array(log_image, dtype = np.uint8)
   
# Display both images
plt.imshow(image)
plt.show()
plt.imshow(log_image)
plt.show()

"""2 gamma transformation """

import cv2
import numpy as np
import matplotlib.pyplot as plt
  
# Open the image.
img = cv2.imread('/content/gamma_airstrip.jpg')
  
# Trying 4 gamma values.
for gamma in [0.5, 1, 2.5]:
      
    # Apply gamma correction.
    gamma_corrected = np.array(255*(img / 255) ** gamma, dtype = 'uint8')
  
    # Save edited images.
    cv2.imwrite('gamma_transformed'+str(gamma)+'.jpg', gamma_corrected)
    plt.title('gamma_transformed '+str(gamma))

    plt.imshow(gamma_corrected)
    plt.show()

"""3.1 Rgb to grey scale"""

# Commented out IPython magic to ensure Python compatibility.
import cv2
import numpy as np
import matplotlib.pyplot as plt
# %matplotlib inline

img_path = '/content/low_contrast.jpg'

img = cv2.imread(img_path)
print(img.shape)
#(1300, 1950, 3)

#Matplotlib EXPECTS RGB (Red Greed Blue)
#but...
#OPENCV reads as Blue Green Red

#we need to transform this in order that Matplotlib reads it correctly
fix_img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)
plt.imshow(fix_img)

#Let's extract the three channels
R, G, B = fix_img[:,:,0], fix_img[:,:,1],fix_img[:,:,2]

Y = 0.2126 * R + 0.7152 * G + 0.0722 * B
print(Y)
plt.imshow(Y, cmap='gray')
plt.savefig('image_weighted_average_byhand.png')

"""3.2 ploat histogram """

# load an image in grayscale mode
img = cv2.imread('/content/low_contrast.jpg',0)
  
# calculate frequency of pixels in range 0-255
histg = cv2.calcHist([img],[0],None,[256],[0,256]) 

# importing required libraries of opencv
import cv2
  
# importing library for plotting
from matplotlib import pyplot as plt
  
# reads an input image
img = cv2.imread('/content/low_contrast.jpg',0)
  
# find frequency of pixels in range 0-255
histr = cv2.calcHist([img],[0],None,[256],[0,256])
  
# show the plotting graph of an image
plt.plot(histr)
plt.show()

"""3.3"""

# load an image in grayscale mode
img = cv2.imread('/content/image_weighted_average_byhand.png',0)
  
# calculate frequency of pixels in range 0-255
histg = cv2.calcHist([img],[0],None,[256],[0,256]) 

# importing required libraries of opencv
import cv2
  
# importing library for plotting
from matplotlib import pyplot as plt
  
# reads an input image
img = cv2.imread('/content/image_weighted_average_byhand.png',0)
  
# find frequency of pixels in range 0-255
histr = cv2.calcHist([img],[0],None,[256],[0,256])
  
# show the plotting graph of an image
plt.plot(histr)
plt.show()

"""4.1 box filter"""

import cv2
import numpy as np
from matplotlib import pyplot as plt

img = cv2.imread('/content/chip.png')

kernel = np.ones((3,3),np.float32)/9
dst = cv2.filter2D(img,-1,kernel)

plt.subplot(121),plt.imshow(img),plt.title('Original')
plt.xticks([]), plt.yticks([])
plt.subplot(122),plt.imshow(dst),plt.title('Averaging')
plt.xticks([]), plt.yticks([])
plt.show()

import cv2
import numpy as np
from matplotlib import pyplot as plt

img = cv2.imread('/content/chip.png')

blur = cv2.blur(img,(3,3))

plt.subplot(121),plt.imshow(img),plt.title('Original')
plt.xticks([]), plt.yticks([])
plt.subplot(122),plt.imshow(blur),plt.title('Blurred')
plt.xticks([]), plt.yticks([])
plt.show()

"""4.2 gaussian filter"""

# Load image:
input_image = Image.open("/content/chip.png")
input_pixels = input_image.load()

# Box Blur kernel
box_kernel = [[1 / 16, 2 / 16, 1 / 16],
              [2 / 16, 4 / 16, 2 / 16],
              [1 / 16, 2 / 16, 1 / 16]]

# Gaussian kernel
gaussian_kernel= [[1 / 256, 4  / 256,  6 / 256,  4 / 256, 1 / 256],
                   [4 / 256, 16 / 256, 24 / 256, 16 / 256, 4 / 256],
                   [6 / 256, 24 / 256, 36 / 256, 24 / 256, 6 / 256],
                   [4 / 256, 16 / 256, 24 / 256, 16 / 256, 4 / 256],
                   [1 / 256, 4  / 256,  6 / 256,  4 / 256, 1 / 256]]

# Select kernel here:
kernel = box_kernel

# Middle of the kernel
offset = len(kernel) // 2

# Create output image
output_image = Image.new("RGB", input_image.size)
draw = ImageDraw.Draw(output_image)

# Compute convolution between intensity and kernels
for x in range(offset, input_image.width - offset):
    for y in range(offset, input_image.height - offset):
        acc = [0, 0, 0]
        for a in range(len(kernel)):
            for b in range(len(kernel)):
                xn = x + a - offset
                yn = y + b - offset
                pixel = input_pixels[xn, yn]
                acc[0] += pixel[0] * kernel[a][b]
                acc[1] += pixel[1] * kernel[a][b]
                acc[2] += pixel[2] * kernel[a][b]

        draw.point((x, y), (int(acc[0]), int(acc[1]), int(acc[2])))
    
output_image.save("output.png")

"""5"""

import cv2
import matplotlib.pyplot as plt

source = cv2.imread('/content/brain.jpg', cv2.IMREAD_COLOR)

source = cv2.GaussianBlur(source, (3, 3), 0)  #remove noise

source_gray = cv2.cvtColor(source, cv2.COLOR_BGR2GRAY)  #convert to gray scale

dest = cv2.Laplacian(source_gray, cv2.CV_16S, ksize=3)
abs_dest = cv2.convertScaleAbs(dest)  #apply laplacian filter

plt.imshow(abs_dest, cmap="gray") #show the output